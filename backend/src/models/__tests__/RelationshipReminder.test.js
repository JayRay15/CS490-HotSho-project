import { jest, beforeEach, describe, it, expect } from '@jest/globals';
import mongoose from 'mongoose';
import RelationshipReminder from '../RelationshipReminder.js';

describe('RelationshipReminder Model', () => {
  describe('Schema Validation', () => {
    it('should validate required fields', () => {
      const reminder = new RelationshipReminder({});

      const error = reminder.validateSync();
      expect(error).toBeDefined();
      expect(error.errors.userId).toBeDefined();
      expect(error.errors.contactId).toBeDefined();
      expect(error.errors.reminderType).toBeDefined();
      expect(error.errors.reminderDate).toBeDefined();
      expect(error.errors.title).toBeDefined();
    });

    it('should create reminder with valid required fields', () => {
      const reminder = new RelationshipReminder({
        userId: 'user_123',
        contactId: new mongoose.Types.ObjectId(),
        reminderType: 'General Check-in',
        reminderDate: new Date(),
        title: 'Check in with John'
      });

      const error = reminder.validateSync();
      expect(error).toBeUndefined();
      expect(reminder.userId).toBe('user_123');
      expect(reminder.reminderType).toBe('General Check-in');
    });

    it('should set default values correctly', () => {
      const reminder = new RelationshipReminder({
        userId: 'user_123',
        contactId: new mongoose.Types.ObjectId(),
        reminderType: 'Follow-up',
        reminderDate: new Date(),
        title: 'Follow up meeting'
      });

      expect(reminder.priority).toBe('Medium');
      expect(reminder.status).toBe('Pending');
      expect(reminder.isRecurring).toBe(false);
      expect(reminder.autoGenerated).toBe(false);
    });

    it('should validate reminderType enum values', () => {
      const validTypes = [
        'General Check-in',
        'Birthday',
        'Work Anniversary',
        'Industry News Share',
        'Congratulations',
        'Thank You',
        'Follow-up',
        'Coffee Chat',
        'Relationship Maintenance',
        'Custom'
      ];

      validTypes.forEach(type => {
        const reminder = new RelationshipReminder({
          userId: 'user_123',
          contactId: new mongoose.Types.ObjectId(),
          reminderType: type,
          reminderDate: new Date(),
          title: 'Test reminder'
        });

        const error = reminder.validateSync();
        expect(error).toBeUndefined();
      });
    });

    it('should reject invalid reminderType', () => {
      const reminder = new RelationshipReminder({
        userId: 'user_123',
        contactId: new mongoose.Types.ObjectId(),
        reminderType: 'InvalidType',
        reminderDate: new Date(),
        title: 'Test reminder'
      });

      const error = reminder.validateSync();
      expect(error).toBeDefined();
      expect(error.errors.reminderType).toBeDefined();
    });

    it('should validate priority enum values', () => {
      const validPriorities = ['High', 'Medium', 'Low'];

      validPriorities.forEach(priority => {
        const reminder = new RelationshipReminder({
          userId: 'user_123',
          contactId: new mongoose.Types.ObjectId(),
          reminderType: 'General Check-in',
          reminderDate: new Date(),
          title: 'Test reminder',
          priority
        });

        const error = reminder.validateSync();
        expect(error).toBeUndefined();
        expect(reminder.priority).toBe(priority);
      });
    });

    it('should reject invalid priority', () => {
      const reminder = new RelationshipReminder({
        userId: 'user_123',
        contactId: new mongoose.Types.ObjectId(),
        reminderType: 'General Check-in',
        reminderDate: new Date(),
        title: 'Test reminder',
        priority: 'InvalidPriority'
      });

      const error = reminder.validateSync();
      expect(error).toBeDefined();
      expect(error.errors.priority).toBeDefined();
    });

    it('should validate status enum values', () => {
      const validStatuses = ['Pending', 'Completed', 'Dismissed', 'Snoozed'];

      validStatuses.forEach(status => {
        const reminder = new RelationshipReminder({
          userId: 'user_123',
          contactId: new mongoose.Types.ObjectId(),
          reminderType: 'General Check-in',
          reminderDate: new Date(),
          title: 'Test reminder',
          status
        });

        const error = reminder.validateSync();
        expect(error).toBeUndefined();
        expect(reminder.status).toBe(status);
      });
    });

    it('should reject invalid status', () => {
      const reminder = new RelationshipReminder({
        userId: 'user_123',
        contactId: new mongoose.Types.ObjectId(),
        reminderType: 'General Check-in',
        reminderDate: new Date(),
        title: 'Test reminder',
        status: 'InvalidStatus'
      });

      const error = reminder.validateSync();
      expect(error).toBeDefined();
      expect(error.errors.status).toBeDefined();
    });

    it('should validate recurrencePattern enum values', () => {
      const validPatterns = ['Daily', 'Weekly', 'Biweekly', 'Monthly', 'Quarterly', 'Yearly', 'Custom'];

      validPatterns.forEach(pattern => {
        const reminder = new RelationshipReminder({
          userId: 'user_123',
          contactId: new mongoose.Types.ObjectId(),
          reminderType: 'General Check-in',
          reminderDate: new Date(),
          title: 'Test reminder',
          isRecurring: true,
          recurrencePattern: pattern
        });

        const error = reminder.validateSync();
        expect(error).toBeUndefined();
      });
    });

    it('should reject invalid recurrencePattern', () => {
      const reminder = new RelationshipReminder({
        userId: 'user_123',
        contactId: new mongoose.Types.ObjectId(),
        reminderType: 'General Check-in',
        reminderDate: new Date(),
        title: 'Test reminder',
        isRecurring: true,
        recurrencePattern: 'InvalidPattern'
      });

      const error = reminder.validateSync();
      expect(error).toBeDefined();
      expect(error.errors.recurrencePattern).toBeDefined();
    });

    it('should trim title', () => {
      const reminder = new RelationshipReminder({
        userId: 'user_123',
        contactId: new mongoose.Types.ObjectId(),
        reminderType: 'General Check-in',
        reminderDate: new Date(),
        title: '  Check in with John  '
      });

      const error = reminder.validateSync();
      expect(error).toBeUndefined();
      expect(reminder.title).toBe('Check in with John');
    });

    it('should trim description', () => {
      const reminder = new RelationshipReminder({
        userId: 'user_123',
        contactId: new mongoose.Types.ObjectId(),
        reminderType: 'General Check-in',
        reminderDate: new Date(),
        title: 'Check in',
        description: '  Remember to ask about new project  '
      });

      const error = reminder.validateSync();
      expect(error).toBeUndefined();
      expect(reminder.description).toBe('Remember to ask about new project');
    });

    it('should trim suggestedMessage', () => {
      const reminder = new RelationshipReminder({
        userId: 'user_123',
        contactId: new mongoose.Types.ObjectId(),
        reminderType: 'General Check-in',
        reminderDate: new Date(),
        title: 'Check in',
        suggestedMessage: '  Hi John, hope you are doing well!  '
      });

      const error = reminder.validateSync();
      expect(error).toBeUndefined();
      expect(reminder.suggestedMessage).toBe('Hi John, hope you are doing well!');
    });

    it('should trim completedNotes', () => {
      const reminder = new RelationshipReminder({
        userId: 'user_123',
        contactId: new mongoose.Types.ObjectId(),
        reminderType: 'General Check-in',
        reminderDate: new Date(),
        title: 'Check in',
        status: 'Completed',
        completedNotes: '  Had a great conversation  '
      });

      const error = reminder.validateSync();
      expect(error).toBeUndefined();
      expect(reminder.completedNotes).toBe('Had a great conversation');
    });

    it('should trim generationReason', () => {
      const reminder = new RelationshipReminder({
        userId: 'user_123',
        contactId: new mongoose.Types.ObjectId(),
        reminderType: 'General Check-in',
        reminderDate: new Date(),
        title: 'Check in',
        autoGenerated: true,
        generationReason: '  No contact in 30 days  '
      });

      const error = reminder.validateSync();
      expect(error).toBeUndefined();
      expect(reminder.generationReason).toBe('No contact in 30 days');
    });

    it('should trim templateUsed', () => {
      const reminder = new RelationshipReminder({
        userId: 'user_123',
        contactId: new mongoose.Types.ObjectId(),
        reminderType: 'General Check-in',
        reminderDate: new Date(),
        title: 'Check in',
        templateUsed: '  check_in_template_1  '
      });

      const error = reminder.validateSync();
      expect(error).toBeUndefined();
      expect(reminder.templateUsed).toBe('check_in_template_1');
    });

    it('should handle relatedIndustryNews array', () => {
      const reminder = new RelationshipReminder({
        userId: 'user_123',
        contactId: new mongoose.Types.ObjectId(),
        reminderType: 'Industry News Share',
        reminderDate: new Date(),
        title: 'Share tech news',
        relatedIndustryNews: [
          {
            title: 'New Tech Trend',
            url: 'https://example.com/news',
            source: 'TechCrunch',
            relevance: 'High'
          }
        ]
      });

      expect(reminder.relatedIndustryNews).toHaveLength(1);
      expect(reminder.relatedIndustryNews[0].title).toBe('New Tech Trend');
      expect(reminder.relatedIndustryNews[0].source).toBe('TechCrunch');
    });

    it('should handle engagementMetrics subdocument', () => {
      const reminder = new RelationshipReminder({
        userId: 'user_123',
        contactId: new mongoose.Types.ObjectId(),
        reminderType: 'General Check-in',
        reminderDate: new Date(),
        title: 'Check in',
        engagementMetrics: {
          opened: true,
          openedAt: new Date(),
          responseReceived: false,
          interactionLogged: false
        }
      });

      expect(reminder.engagementMetrics.opened).toBe(true);
      expect(reminder.engagementMetrics.responseReceived).toBe(false);
    });

    it('should handle completedAt date', () => {
      const completedDate = new Date();
      const reminder = new RelationshipReminder({
        userId: 'user_123',
        contactId: new mongoose.Types.ObjectId(),
        reminderType: 'General Check-in',
        reminderDate: new Date(),
        title: 'Check in',
        status: 'Completed',
        completedAt: completedDate
      });

      expect(reminder.completedAt).toEqual(completedDate);
    });

    it('should handle snoozedUntil date', () => {
      const snoozeDate = new Date();
      snoozeDate.setDate(snoozeDate.getDate() + 3);
      
      const reminder = new RelationshipReminder({
        userId: 'user_123',
        contactId: new mongoose.Types.ObjectId(),
        reminderType: 'General Check-in',
        reminderDate: new Date(),
        title: 'Check in',
        status: 'Snoozed',
        snoozedUntil: snoozeDate
      });

      expect(reminder.snoozedUntil).toEqual(snoozeDate);
    });

    it('should handle recurrenceInterval as number', () => {
      const reminder = new RelationshipReminder({
        userId: 'user_123',
        contactId: new mongoose.Types.ObjectId(),
        reminderType: 'General Check-in',
        reminderDate: new Date(),
        title: 'Check in',
        isRecurring: true,
        recurrencePattern: 'Custom',
        recurrenceInterval: 45
      });

      expect(reminder.recurrenceInterval).toBe(45);
    });

    it('should handle nextRecurrenceDate', () => {
      const nextDate = new Date();
      nextDate.setMonth(nextDate.getMonth() + 1);
      
      const reminder = new RelationshipReminder({
        userId: 'user_123',
        contactId: new mongoose.Types.ObjectId(),
        reminderType: 'General Check-in',
        reminderDate: new Date(),
        title: 'Check in',
        isRecurring: true,
        recurrencePattern: 'Monthly',
        nextRecurrenceDate: nextDate
      });

      expect(reminder.nextRecurrenceDate).toEqual(nextDate);
    });
  });

  describe('complete Method', () => {
    it('should mark reminder as completed with notes', async () => {
      const reminder = new RelationshipReminder({
        userId: 'user_123',
        contactId: new mongoose.Types.ObjectId(),
        reminderType: 'General Check-in',
        reminderDate: new Date(),
        title: 'Check in'
      });

      // Mock save method
      reminder.save = jest.fn().mockResolvedValue(reminder);

      await reminder.complete('Had a great conversation');

      expect(reminder.status).toBe('Completed');
      expect(reminder.completedAt).toBeDefined();
      expect(reminder.completedNotes).toBe('Had a great conversation');
      expect(reminder.save).toHaveBeenCalled();
    });

    it('should mark reminder as completed without notes', async () => {
      const reminder = new RelationshipReminder({
        userId: 'user_123',
        contactId: new mongoose.Types.ObjectId(),
        reminderType: 'General Check-in',
        reminderDate: new Date(),
        title: 'Check in'
      });

      reminder.save = jest.fn().mockResolvedValue(reminder);

      await reminder.complete();

      expect(reminder.status).toBe('Completed');
      expect(reminder.completedAt).toBeDefined();
      expect(reminder.completedNotes).toBeUndefined();
    });

    it('should create next recurring reminder for Daily pattern', async () => {
      const originalDate = new Date('2024-01-15');
      const nextDate = new Date('2024-01-16');
      
      const reminder = new RelationshipReminder({
        userId: 'user_123',
        contactId: new mongoose.Types.ObjectId(),
        reminderType: 'General Check-in',
        reminderDate: originalDate,
        title: 'Daily check in',
        isRecurring: true,
        recurrencePattern: 'Daily',
        nextRecurrenceDate: nextDate
      });

      // Mock the prototype.save to intercept all save calls
      const originalSave = RelationshipReminder.prototype.save;
      RelationshipReminder.prototype.save = jest.fn().mockImplementation(function() {
        return Promise.resolve(this);
      });

      await reminder.complete();

      expect(reminder.status).toBe('Completed');
      expect(RelationshipReminder.prototype.save).toHaveBeenCalled();
      
      // Restore original
      RelationshipReminder.prototype.save = originalSave;
    });

    it('should create next recurring reminder for Weekly pattern', async () => {
      const originalDate = new Date('2024-01-15');
      const nextDate = new Date('2024-01-22');
      
      const reminder = new RelationshipReminder({
        userId: 'user_123',
        contactId: new mongoose.Types.ObjectId(),
        reminderType: 'General Check-in',
        reminderDate: originalDate,
        title: 'Weekly check in',
        isRecurring: true,
        recurrencePattern: 'Weekly',
        nextRecurrenceDate: nextDate
      });

      // Mock the prototype.save to intercept all save calls
      const originalSave = RelationshipReminder.prototype.save;
      RelationshipReminder.prototype.save = jest.fn().mockImplementation(function() {
        return Promise.resolve(this);
      });

      await reminder.complete();

      expect(reminder.status).toBe('Completed');
      expect(RelationshipReminder.prototype.save).toHaveBeenCalled();
      
      // Restore original
      RelationshipReminder.prototype.save = originalSave;
    });

    it('should create next recurring reminder for Custom pattern', async () => {
      const originalDate = new Date('2024-01-15');
      const nextDate = new Date('2024-01-30');
      
      const reminder = new RelationshipReminder({
        userId: 'user_123',
        contactId: new mongoose.Types.ObjectId(),
        reminderType: 'General Check-in',
        reminderDate: originalDate,
        title: 'Custom check in',
        isRecurring: true,
        recurrencePattern: 'Custom',
        recurrenceInterval: 15,
        nextRecurrenceDate: nextDate
      });

      // Mock the prototype.save to intercept all save calls
      const originalSave = RelationshipReminder.prototype.save;
      RelationshipReminder.prototype.save = jest.fn().mockImplementation(function() {
        return Promise.resolve(this);
      });

      await reminder.complete();

      expect(reminder.status).toBe('Completed');
      expect(RelationshipReminder.prototype.save).toHaveBeenCalled();
      
      // Restore original
      RelationshipReminder.prototype.save = originalSave;
    });

    it('should create next recurring reminder for Biweekly pattern', async () => {
      const originalDate = new Date('2024-01-15');
      const nextDate = new Date('2024-01-29');
      
      const reminder = new RelationshipReminder({
        userId: 'user_123',
        contactId: new mongoose.Types.ObjectId(),
        reminderType: 'General Check-in',
        reminderDate: originalDate,
        title: 'Biweekly check in',
        isRecurring: true,
        recurrencePattern: 'Biweekly',
        nextRecurrenceDate: nextDate
      });

      const originalSave = RelationshipReminder.prototype.save;
      RelationshipReminder.prototype.save = jest.fn().mockImplementation(function() {
        return Promise.resolve(this);
      });

      await reminder.complete();

      expect(reminder.status).toBe('Completed');
      expect(RelationshipReminder.prototype.save).toHaveBeenCalled();
      
      RelationshipReminder.prototype.save = originalSave;
    });

    it('should create next recurring reminder for Monthly pattern', async () => {
      const originalDate = new Date('2024-01-15');
      const nextDate = new Date('2024-02-15');
      
      const reminder = new RelationshipReminder({
        userId: 'user_123',
        contactId: new mongoose.Types.ObjectId(),
        reminderType: 'General Check-in',
        reminderDate: originalDate,
        title: 'Monthly check in',
        isRecurring: true,
        recurrencePattern: 'Monthly',
        nextRecurrenceDate: nextDate
      });

      const originalSave = RelationshipReminder.prototype.save;
      RelationshipReminder.prototype.save = jest.fn().mockImplementation(function() {
        return Promise.resolve(this);
      });

      await reminder.complete();

      expect(reminder.status).toBe('Completed');
      expect(RelationshipReminder.prototype.save).toHaveBeenCalled();
      
      RelationshipReminder.prototype.save = originalSave;
    });

    it('should create next recurring reminder for Quarterly pattern', async () => {
      const originalDate = new Date('2024-01-15');
      const nextDate = new Date('2024-04-15');
      
      const reminder = new RelationshipReminder({
        userId: 'user_123',
        contactId: new mongoose.Types.ObjectId(),
        reminderType: 'General Check-in',
        reminderDate: originalDate,
        title: 'Quarterly check in',
        isRecurring: true,
        recurrencePattern: 'Quarterly',
        nextRecurrenceDate: nextDate
      });

      const originalSave = RelationshipReminder.prototype.save;
      RelationshipReminder.prototype.save = jest.fn().mockImplementation(function() {
        return Promise.resolve(this);
      });

      await reminder.complete();

      expect(reminder.status).toBe('Completed');
      expect(RelationshipReminder.prototype.save).toHaveBeenCalled();
      
      RelationshipReminder.prototype.save = originalSave;
    });

    it('should create next recurring reminder for Yearly pattern', async () => {
      const originalDate = new Date('2024-01-15');
      const nextDate = new Date('2025-01-15');
      
      const reminder = new RelationshipReminder({
        userId: 'user_123',
        contactId: new mongoose.Types.ObjectId(),
        reminderType: 'General Check-in',
        reminderDate: originalDate,
        title: 'Yearly check in',
        isRecurring: true,
        recurrencePattern: 'Yearly',
        nextRecurrenceDate: nextDate
      });

      const originalSave = RelationshipReminder.prototype.save;
      RelationshipReminder.prototype.save = jest.fn().mockImplementation(function() {
        return Promise.resolve(this);
      });

      await reminder.complete();

      expect(reminder.status).toBe('Completed');
      expect(RelationshipReminder.prototype.save).toHaveBeenCalled();
      
      RelationshipReminder.prototype.save = originalSave;
    });
  });

  describe('snooze Method', () => {
    it('should snooze reminder for specified days', async () => {
      const reminder = new RelationshipReminder({
        userId: 'user_123',
        contactId: new mongoose.Types.ObjectId(),
        reminderType: 'General Check-in',
        reminderDate: new Date(),
        title: 'Check in'
      });

      reminder.save = jest.fn().mockResolvedValue(reminder);
      const daysToSnooze = 3;

      const beforeSnooze = new Date();
      await reminder.snooze(daysToSnooze);
      const afterSnooze = new Date();

      expect(reminder.status).toBe('Snoozed');
      expect(reminder.snoozedUntil).toBeDefined();
      
      // Verify snoozedUntil is approximately 3 days from now
      const expectedSnoozeDate = new Date(beforeSnooze);
      expectedSnoozeDate.setDate(expectedSnoozeDate.getDate() + daysToSnooze);
      
      expect(reminder.snoozedUntil.getTime()).toBeGreaterThanOrEqual(expectedSnoozeDate.getTime() - 1000);
      expect(reminder.snoozedUntil.getTime()).toBeLessThanOrEqual(expectedSnoozeDate.getTime() + 1000);
      expect(reminder.save).toHaveBeenCalled();
    });

    it('should snooze for 1 day', async () => {
      const reminder = new RelationshipReminder({
        userId: 'user_123',
        contactId: new mongoose.Types.ObjectId(),
        reminderType: 'General Check-in',
        reminderDate: new Date(),
        title: 'Check in'
      });

      reminder.save = jest.fn().mockResolvedValue(reminder);

      await reminder.snooze(1);

      expect(reminder.status).toBe('Snoozed');
      expect(reminder.snoozedUntil).toBeDefined();
    });

    it('should snooze for 7 days', async () => {
      const reminder = new RelationshipReminder({
        userId: 'user_123',
        contactId: new mongoose.Types.ObjectId(),
        reminderType: 'General Check-in',
        reminderDate: new Date(),
        title: 'Check in'
      });

      reminder.save = jest.fn().mockResolvedValue(reminder);

      await reminder.snooze(7);

      expect(reminder.status).toBe('Snoozed');
      expect(reminder.snoozedUntil).toBeDefined();
    });
  });

  describe('Indexes', () => {
    it('should have proper schema indexes defined', () => {
      const indexes = RelationshipReminder.schema.indexes();
      
      expect(indexes).toBeDefined();
      expect(indexes.length).toBeGreaterThan(0);
    });
  });

  describe('Timestamps', () => {
    it('should have timestamps enabled', () => {
      const reminder = new RelationshipReminder({
        userId: 'user_123',
        contactId: new mongoose.Types.ObjectId(),
        reminderType: 'General Check-in',
        reminderDate: new Date(),
        title: 'Check in'
      });

      // Schema should have timestamps option
      expect(RelationshipReminder.schema.options.timestamps).toBe(true);
    });
  });
});
