import mongoose from 'mongoose';

/**
 * FollowUpReminder Model
 * 
 * Manages intelligent follow-up reminders based on application stage.
 * Features:
 * - Auto-scheduling based on application stage
 * - Company responsiveness tracking
 * - Snooze/dismiss functionality
 * - Follow-up completion tracking
 * - Email template suggestions
 */

const followUpReminderSchema = new mongoose.Schema({
  userId: {
    type: String,
    required: true,
    index: true
  },
  jobId: {
    type: mongoose.Schema.Types.ObjectId,
    ref: 'Job',
    required: true,
    index: true
  },
  
  // Application stage this reminder is for
  applicationStage: {
    type: String,
    enum: [
      'Applied',
      'Under Review',
      'Phone Screen',
      'Technical Interview',
      'Onsite Interview',
      'Final Interview',
      'Offer Extended',
      'Offer Accepted',
      'Offer Declined',
      'Rejected',
      'Withdrawn',
      'Ghosted'
    ],
    required: true
  },
  
  // Reminder type based on stage
  reminderType: {
    type: String,
    enum: [
      'application-follow-up',     // 1 week after application
      'post-interview-thank-you',  // 24 hours after interview
      'post-interview-follow-up',  // 3 days after interview
      'status-inquiry',            // 1 week after interview if no response
      'feedback-request',          // After rejection
      'offer-response',            // Pending offer response
      'networking-follow-up',      // After rejection/withdrawn
      'custom'
    ],
    required: true
  },
  
  // Scheduling
  scheduledDate: {
    type: Date,
    required: true,
    index: true
  },
  
  // Original scheduled date (before any snoozes)
  originalScheduledDate: {
    type: Date
  },
  
  // Status of the reminder
  status: {
    type: String,
    enum: ['pending', 'completed', 'snoozed', 'dismissed', 'expired'],
    default: 'pending',
    index: true
  },
  
  // Priority level
  priority: {
    type: String,
    enum: ['high', 'medium', 'low'],
    default: 'medium'
  },
  
  // Reminder title
  title: {
    type: String,
    required: true,
    trim: true
  },
  
  // Detailed description
  description: {
    type: String,
    trim: true
  },
  
  // Suggested email template type
  suggestedTemplateType: {
    type: String,
    enum: ['thank-you', 'status-inquiry', 'feedback-request', 'networking'],
    default: 'status-inquiry'
  },
  
  // Follow-up etiquette tips for this type of reminder
  etiquetteTips: [{
    tip: String,
    importance: {
      type: String,
      enum: ['critical', 'important', 'helpful'],
      default: 'helpful'
    }
  }],
  
  // Company responsiveness tracking
  companyResponsiveness: {
    previousFollowUpCount: {
      type: Number,
      default: 0
    },
    lastFollowUpDate: Date,
    responseReceived: {
      type: Boolean,
      default: false
    },
    responseReceivedAt: Date,
    avgResponseTime: Number, // in days
    responsiveness: {
      type: String,
      enum: ['highly-responsive', 'responsive', 'slow', 'unresponsive', 'unknown'],
      default: 'unknown'
    }
  },
  
  // Snooze tracking
  snoozeHistory: [{
    snoozedAt: {
      type: Date,
      default: Date.now
    },
    snoozedUntil: Date,
    reason: String
  }],
  
  // Completion tracking
  completedAt: Date,
  completionMethod: {
    type: String,
    enum: ['email-sent', 'marked-complete', 'auto-expired', 'dismissed'],
    default: null
  },
  completionNotes: String,
  
  // Reference to the follow-up that was sent (if any)
  followUpId: {
    type: mongoose.Schema.Types.ObjectId,
    ref: 'FollowUp'
  },
  
  // Auto-generated flag
  autoGenerated: {
    type: Boolean,
    default: true
  },
  
  // Whether user was notified about this reminder
  notificationSent: {
    type: Boolean,
    default: false
  },
  notificationSentAt: Date,
  
  // Reminder frequency adjustment based on company responsiveness
  adjustedFrequency: {
    originalDays: Number,    // Original days until reminder
    adjustedDays: Number,    // Adjusted days based on responsiveness
    adjustmentReason: String // Why it was adjusted
  }
}, {
  timestamps: true
});

// Indexes for efficient querying
followUpReminderSchema.index({ userId: 1, status: 1, scheduledDate: 1 });
followUpReminderSchema.index({ userId: 1, jobId: 1, status: 1 });
followUpReminderSchema.index({ scheduledDate: 1, status: 1 });
followUpReminderSchema.index({ 'companyResponsiveness.responsiveness': 1 });

// Virtual for days until reminder
followUpReminderSchema.virtual('daysUntilReminder').get(function() {
  if (!this.scheduledDate) return null;
  const now = new Date();
  now.setHours(0, 0, 0, 0);
  const scheduled = new Date(this.scheduledDate);
  scheduled.setHours(0, 0, 0, 0);
  return Math.ceil((scheduled - now) / (1000 * 60 * 60 * 24));
});

// Virtual for whether reminder is overdue
followUpReminderSchema.virtual('isOverdue').get(function() {
  if (!this.scheduledDate || this.status !== 'pending') return false;
  return new Date() > this.scheduledDate;
});

// Method to snooze reminder
followUpReminderSchema.methods.snooze = function(days, reason = '') {
  const snoozedUntil = new Date();
  snoozedUntil.setDate(snoozedUntil.getDate() + days);
  
  this.snoozeHistory.push({
    snoozedAt: new Date(),
    snoozedUntil,
    reason
  });
  
  this.scheduledDate = snoozedUntil;
  this.status = 'snoozed';
  
  return this;
};

// Method to dismiss reminder
followUpReminderSchema.methods.dismiss = function(reason = '') {
  this.status = 'dismissed';
  this.completedAt = new Date();
  this.completionMethod = 'dismissed';
  this.completionNotes = reason;
  
  return this;
};

// Method to mark as completed
followUpReminderSchema.methods.complete = function(method = 'marked-complete', notes = '', followUpId = null) {
  this.status = 'completed';
  this.completedAt = new Date();
  this.completionMethod = method;
  this.completionNotes = notes;
  if (followUpId) {
    this.followUpId = followUpId;
  }
  
  return this;
};

// Method to update company responsiveness
followUpReminderSchema.methods.updateResponsiveness = function(responseReceived, responseTime = null) {
  this.companyResponsiveness.responseReceived = responseReceived;
  
  if (responseReceived) {
    this.companyResponsiveness.responseReceivedAt = new Date();
    
    if (responseTime) {
      this.companyResponsiveness.avgResponseTime = responseTime;
      
      // Determine responsiveness level
      if (responseTime <= 2) {
        this.companyResponsiveness.responsiveness = 'highly-responsive';
      } else if (responseTime <= 5) {
        this.companyResponsiveness.responsiveness = 'responsive';
      } else if (responseTime <= 10) {
        this.companyResponsiveness.responsiveness = 'slow';
      } else {
        this.companyResponsiveness.responsiveness = 'unresponsive';
      }
    }
  }
  
  return this;
};

// Static method to get pending reminders for user
followUpReminderSchema.statics.getPendingReminders = async function(userId, options = {}) {
  const { includeSnoozed = true, limit = 20 } = options;
  
  const statuses = ['pending'];
  if (includeSnoozed) statuses.push('snoozed');
  
  return this.find({
    userId,
    status: { $in: statuses },
    scheduledDate: { $lte: new Date(Date.now() + 7 * 24 * 60 * 60 * 1000) } // Next 7 days
  })
    .populate('jobId', 'title company status')
    .sort({ scheduledDate: 1 })
    .limit(limit);
};

// Static method to get overdue reminders
followUpReminderSchema.statics.getOverdueReminders = async function(userId) {
  return this.find({
    userId,
    status: 'pending',
    scheduledDate: { $lt: new Date() }
  })
    .populate('jobId', 'title company status')
    .sort({ scheduledDate: 1 });
};

// Pre-save middleware
followUpReminderSchema.pre('save', function(next) {
  // Save original scheduled date on first save
  if (this.isNew && !this.originalScheduledDate) {
    this.originalScheduledDate = this.scheduledDate;
  }
  
  // Reset status from snoozed to pending if snooze period has passed
  if (this.status === 'snoozed' && this.scheduledDate <= new Date()) {
    this.status = 'pending';
  }
  
  next();
});

export const FollowUpReminder = mongoose.model('FollowUpReminder', followUpReminderSchema);
