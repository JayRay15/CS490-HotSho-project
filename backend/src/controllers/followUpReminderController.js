import { FollowUpReminder } from '../models/FollowUpReminder.js';
import { Job } from '../models/Job.js';
import { ApplicationStatus } from '../models/ApplicationStatus.js';
import {
  createFollowUpReminder,
  createSecondaryFollowUpReminder,
  handleStatusChange,
  markReminderComplete,
  updateResponsivenessOnResponse,
  getCompanyResponsiveness,
  getEtiquetteTips
} from '../utils/followUpReminderService.js';

/**
 * Get all follow-up reminders for the current user
 */
export const getAllReminders = async (req, res) => {
  try {
    const userId = req.auth?.userId || req.auth?.payload?.sub;
    
    if (!userId) {
      return res.status(401).json({
        success: false,
        message: 'User ID not found in authentication token'
      });
    }
    
    const { status, limit = 50, includeCompleted = false } = req.query;
    
    const query = { userId };
    
    if (status) {
      query.status = status;
    } else if (!includeCompleted || includeCompleted === 'false') {
      query.status = { $in: ['pending', 'snoozed'] };
    }
    
    const reminders = await FollowUpReminder.find(query)
      .populate('jobId', 'title company status location')
      .populate('followUpId', 'subject sentAt responseReceived')
      .sort({ scheduledDate: 1 })
      .limit(parseInt(limit));
    
    res.json({
      success: true,
      data: reminders,
      count: reminders.length
    });
  } catch (error) {
    console.error('Error fetching reminders:', error);
    res.status(500).json({
      success: false,
      message: 'Failed to fetch reminders',
      error: error.message
    });
  }
};

/**
 * Get reminders for a specific job
 */
export const getJobReminders = async (req, res) => {
  try {
    const userId = req.auth?.userId || req.auth?.payload?.sub;
    const { jobId } = req.params;
    
    if (!userId) {
      return res.status(401).json({
        success: false,
        message: 'User ID not found in authentication token'
      });
    }
    
    // Validate job belongs to user
    const job = await Job.findOne({ _id: jobId, userId });
    if (!job) {
      return res.status(404).json({
        success: false,
        message: 'Job not found'
      });
    }
    
    const reminders = await FollowUpReminder.find({ userId, jobId })
      .populate('followUpId', 'subject sentAt responseReceived')
      .sort({ scheduledDate: -1 });
    
    res.json({
      success: true,
      data: reminders
    });
  } catch (error) {
    console.error('Error fetching job reminders:', error);
    res.status(500).json({
      success: false,
      message: 'Failed to fetch job reminders',
      error: error.message
    });
  }
};

/**
 * Get pending reminders (due within specified days)
 */
export const getPendingReminders = async (req, res) => {
  try {
    const userId = req.auth?.userId || req.auth?.payload?.sub;
    const { days = 7 } = req.query;
    
    if (!userId) {
      return res.status(401).json({
        success: false,
        message: 'User ID not found in authentication token'
      });
    }
    
    const cutoffDate = new Date();
    cutoffDate.setDate(cutoffDate.getDate() + parseInt(days));
    
    const reminders = await FollowUpReminder.find({
      userId,
      status: { $in: ['pending', 'snoozed'] },
      scheduledDate: { $lte: cutoffDate }
    })
      .populate('jobId', 'title company status location')
      .sort({ scheduledDate: 1 });
    
    // Separate overdue from upcoming
    const now = new Date();
    const overdue = reminders.filter(r => r.scheduledDate < now);
    const upcoming = reminders.filter(r => r.scheduledDate >= now);
    
    res.json({
      success: true,
      data: {
        overdue,
        upcoming,
        total: reminders.length
      }
    });
  } catch (error) {
    console.error('Error fetching pending reminders:', error);
    res.status(500).json({
      success: false,
      message: 'Failed to fetch pending reminders',
      error: error.message
    });
  }
};

/**
 * Create a new follow-up reminder
 */
export const createReminder = async (req, res) => {
  try {
    const userId = req.auth?.userId || req.auth?.payload?.sub;
    const { jobId, type, title, description, scheduledDate, priority } = req.body;
    
    if (!userId) {
      return res.status(401).json({
        success: false,
        message: 'User ID not found in authentication token'
      });
    }
    
    if (!jobId) {
      return res.status(400).json({
        success: false,
        message: 'Job ID is required'
      });
    }
    
    const result = await createFollowUpReminder(userId, jobId, {
      type,
      title,
      description,
      baseDate: scheduledDate ? new Date(scheduledDate) : new Date(),
      priority,
      autoGenerated: false,
      force: true
    });
    
    if (result.skipped) {
      return res.status(400).json({
        success: false,
        message: result.reason
      });
    }
    
    res.status(201).json({
      success: true,
      message: result.existing ? 'Existing reminder found' : 'Reminder created successfully',
      data: result.reminder
    });
  } catch (error) {
    console.error('Error creating reminder:', error);
    res.status(500).json({
      success: false,
      message: 'Failed to create reminder',
      error: error.message
    });
  }
};

/**
 * Snooze a reminder
 */
export const snoozeReminder = async (req, res) => {
  try {
    const userId = req.auth?.userId || req.auth?.payload?.sub;
    const { reminderId } = req.params;
    const { days = 1, reason = '' } = req.body;
    
    if (!userId) {
      return res.status(401).json({
        success: false,
        message: 'User ID not found in authentication token'
      });
    }
    
    const reminder = await FollowUpReminder.findOne({ _id: reminderId, userId });
    
    if (!reminder) {
      return res.status(404).json({
        success: false,
        message: 'Reminder not found'
      });
    }
    
    if (reminder.status === 'completed' || reminder.status === 'dismissed') {
      return res.status(400).json({
        success: false,
        message: 'Cannot snooze a completed or dismissed reminder'
      });
    }
    
    reminder.snooze(parseInt(days), reason);
    await reminder.save();
    
    res.json({
      success: true,
      message: `Reminder snoozed for ${days} day(s)`,
      data: reminder
    });
  } catch (error) {
    console.error('Error snoozing reminder:', error);
    res.status(500).json({
      success: false,
      message: 'Failed to snooze reminder',
      error: error.message
    });
  }
};

/**
 * Dismiss a reminder
 */
export const dismissReminder = async (req, res) => {
  try {
    const userId = req.auth?.userId || req.auth?.payload?.sub;
    const { reminderId } = req.params;
    const { reason = '' } = req.body;
    
    if (!userId) {
      return res.status(401).json({
        success: false,
        message: 'User ID not found in authentication token'
      });
    }
    
    const reminder = await FollowUpReminder.findOne({ _id: reminderId, userId });
    
    if (!reminder) {
      return res.status(404).json({
        success: false,
        message: 'Reminder not found'
      });
    }
    
    reminder.dismiss(reason);
    await reminder.save();
    
    res.json({
      success: true,
      message: 'Reminder dismissed',
      data: reminder
    });
  } catch (error) {
    console.error('Error dismissing reminder:', error);
    res.status(500).json({
      success: false,
      message: 'Failed to dismiss reminder',
      error: error.message
    });
  }
};

/**
 * Complete a reminder
 */
export const completeReminder = async (req, res) => {
  try {
    const userId = req.auth?.userId || req.auth?.payload?.sub;
    const { reminderId } = req.params;
    const { method = 'marked-complete', notes = '', followUpId = null } = req.body;
    
    if (!userId) {
      return res.status(401).json({
        success: false,
        message: 'User ID not found in authentication token'
      });
    }
    
    const reminder = await FollowUpReminder.findOne({ _id: reminderId, userId });
    
    if (!reminder) {
      return res.status(404).json({
        success: false,
        message: 'Reminder not found'
      });
    }
    
    reminder.complete(method, notes, followUpId);
    await reminder.save();
    
    res.json({
      success: true,
      message: 'Reminder completed',
      data: reminder
    });
  } catch (error) {
    console.error('Error completing reminder:', error);
    res.status(500).json({
      success: false,
      message: 'Failed to complete reminder',
      error: error.message
    });
  }
};

/**
 * Get reminder statistics
 */
export const getReminderStats = async (req, res) => {
  try {
    const userId = req.auth?.userId || req.auth?.payload?.sub;
    
    if (!userId) {
      return res.status(401).json({
        success: false,
        message: 'User ID not found in authentication token'
      });
    }
    
    const now = new Date();
    
    // Get counts by status
    const statusCounts = await FollowUpReminder.aggregate([
      { $match: { userId } },
      { $group: { _id: '$status', count: { $sum: 1 } } }
    ]);
    
    // Get overdue count
    const overdueCount = await FollowUpReminder.countDocuments({
      userId,
      status: 'pending',
      scheduledDate: { $lt: now }
    });
    
    // Get upcoming count (next 7 days)
    const weekFromNow = new Date();
    weekFromNow.setDate(weekFromNow.getDate() + 7);
    const upcomingCount = await FollowUpReminder.countDocuments({
      userId,
      status: { $in: ['pending', 'snoozed'] },
      scheduledDate: { $gte: now, $lte: weekFromNow }
    });
    
    // Get completion rate
    const totalCompleted = await FollowUpReminder.countDocuments({
      userId,
      status: 'completed'
    });
    const totalReminders = await FollowUpReminder.countDocuments({ userId });
    const completionRate = totalReminders > 0 
      ? Math.round((totalCompleted / totalReminders) * 100) 
      : 0;
    
    // Get average response rate
    const respondedReminders = await FollowUpReminder.countDocuments({
      userId,
      status: 'completed',
      'companyResponsiveness.responseReceived': true
    });
    const responseRate = totalCompleted > 0
      ? Math.round((respondedReminders / totalCompleted) * 100)
      : 0;
    
    res.json({
      success: true,
      data: {
        statusCounts: statusCounts.reduce((acc, item) => {
          acc[item._id] = item.count;
          return acc;
        }, {}),
        overdueCount,
        upcomingCount,
        completionRate,
        responseRate,
        totalReminders
      }
    });
  } catch (error) {
    console.error('Error fetching reminder stats:', error);
    res.status(500).json({
      success: false,
      message: 'Failed to fetch reminder statistics',
      error: error.message
    });
  }
};

/**
 * Get etiquette tips for a reminder type
 */
export const getEtiquetteTipsEndpoint = async (req, res) => {
  try {
    const { type } = req.params;
    
    const tips = getEtiquetteTips(type);
    
    res.json({
      success: true,
      data: {
        type,
        tips
      }
    });
  } catch (error) {
    console.error('Error fetching etiquette tips:', error);
    res.status(500).json({
      success: false,
      message: 'Failed to fetch etiquette tips',
      error: error.message
    });
  }
};

/**
 * Get company responsiveness data
 */
export const getCompanyResponsivenessEndpoint = async (req, res) => {
  try {
    const userId = req.auth?.userId || req.auth?.payload?.sub;
    const { company } = req.params;
    
    if (!userId) {
      return res.status(401).json({
        success: false,
        message: 'User ID not found in authentication token'
      });
    }
    
    if (!company) {
      return res.status(400).json({
        success: false,
        message: 'Company name is required'
      });
    }
    
    const responsiveness = await getCompanyResponsiveness(userId, company);
    
    res.json({
      success: true,
      data: {
        company,
        ...responsiveness
      }
    });
  } catch (error) {
    console.error('Error fetching company responsiveness:', error);
    res.status(500).json({
      success: false,
      message: 'Failed to fetch company responsiveness',
      error: error.message
    });
  }
};

/**
 * Trigger reminder creation for a status change (manual trigger)
 */
export const triggerStatusChangeReminders = async (req, res) => {
  try {
    const userId = req.auth?.userId || req.auth?.payload?.sub;
    const { jobId } = req.params;
    const { newStatus, previousStatus } = req.body;
    
    if (!userId) {
      return res.status(401).json({
        success: false,
        message: 'User ID not found in authentication token'
      });
    }
    
    // Validate job belongs to user
    const job = await Job.findOne({ _id: jobId, userId });
    if (!job) {
      return res.status(404).json({
        success: false,
        message: 'Job not found'
      });
    }
    
    const result = await handleStatusChange(
      userId, 
      jobId, 
      newStatus || job.status, 
      previousStatus
    );
    
    res.json({
      success: true,
      message: result.skipped ? result.reason : 'Reminders updated for status change',
      data: result
    });
  } catch (error) {
    console.error('Error triggering status change reminders:', error);
    res.status(500).json({
      success: false,
      message: 'Failed to update reminders',
      error: error.message
    });
  }
};

/**
 * Mark response received for a completed reminder
 */
export const markResponseReceived = async (req, res) => {
  try {
    const userId = req.auth?.userId || req.auth?.payload?.sub;
    const { reminderId } = req.params;
    const { responseTime } = req.body;
    
    if (!userId) {
      return res.status(401).json({
        success: false,
        message: 'User ID not found in authentication token'
      });
    }
    
    const reminder = await FollowUpReminder.findOne({ _id: reminderId, userId });
    
    if (!reminder) {
      return res.status(404).json({
        success: false,
        message: 'Reminder not found'
      });
    }
    
    reminder.updateResponsiveness(true, responseTime);
    await reminder.save();
    
    res.json({
      success: true,
      message: 'Response marked as received',
      data: reminder
    });
  } catch (error) {
    console.error('Error marking response received:', error);
    res.status(500).json({
      success: false,
      message: 'Failed to mark response',
      error: error.message
    });
  }
};

/**
 * Delete a reminder
 */
export const deleteReminder = async (req, res) => {
  try {
    const userId = req.auth?.userId || req.auth?.payload?.sub;
    const { reminderId } = req.params;
    
    if (!userId) {
      return res.status(401).json({
        success: false,
        message: 'User ID not found in authentication token'
      });
    }
    
    const reminder = await FollowUpReminder.findOneAndDelete({ _id: reminderId, userId });
    
    if (!reminder) {
      return res.status(404).json({
        success: false,
        message: 'Reminder not found'
      });
    }
    
    res.json({
      success: true,
      message: 'Reminder deleted'
    });
  } catch (error) {
    console.error('Error deleting reminder:', error);
    res.status(500).json({
      success: false,
      message: 'Failed to delete reminder',
      error: error.message
    });
  }
};

/**
 * Bulk dismiss reminders for rejected applications
 */
export const dismissRejectedReminders = async (req, res) => {
  try {
    const userId = req.auth?.userId || req.auth?.payload?.sub;
    
    if (!userId) {
      return res.status(401).json({
        success: false,
        message: 'User ID not found in authentication token'
      });
    }
    
    // Find all jobs that are rejected, withdrawn, or ghosted
    const rejectedJobs = await Job.find({
      userId,
      status: { $in: ['Rejected', 'Withdrawn', 'Ghosted'] }
    }).select('_id');
    
    const jobIds = rejectedJobs.map(j => j._id);
    
    const result = await FollowUpReminder.updateMany(
      {
        userId,
        jobId: { $in: jobIds },
        status: { $in: ['pending', 'snoozed'] }
      },
      {
        $set: {
          status: 'dismissed',
          completedAt: new Date(),
          completionMethod: 'dismissed',
          completionNotes: 'Auto-dismissed due to rejected application'
        }
      }
    );
    
    res.json({
      success: true,
      message: `Dismissed ${result.modifiedCount} reminders for rejected applications`,
      data: {
        dismissedCount: result.modifiedCount
      }
    });
  } catch (error) {
    console.error('Error dismissing rejected reminders:', error);
    res.status(500).json({
      success: false,
      message: 'Failed to dismiss reminders',
      error: error.message
    });
  }
};

export default {
  getAllReminders,
  getJobReminders,
  getPendingReminders,
  createReminder,
  snoozeReminder,
  dismissReminder,
  completeReminder,
  getReminderStats,
  getEtiquetteTipsEndpoint,
  getCompanyResponsivenessEndpoint,
  triggerStatusChangeReminders,
  markResponseReceived,
  deleteReminder,
  dismissRejectedReminders
};
