import { FollowUpReminder } from '../models/FollowUpReminder.js';
import { Job } from '../models/Job.js';
import { ApplicationStatus } from '../models/ApplicationStatus.js';
import { User } from '../models/User.js';
import {
  createFollowUpReminder,
  createSecondaryFollowUpReminder,
  handleStatusChange,
  markReminderComplete,
  updateResponsivenessOnResponse,
  getCompanyResponsiveness,
  getEtiquetteTips
} from '../utils/followUpReminderService.js';

/**
 * Get all follow-up reminders for the current user
 */
export const getAllReminders = async (req, res) => {
  try {
    const userId = req.auth?.userId || req.auth?.payload?.sub;
    
    if (!userId) {
      return res.status(401).json({
        success: false,
        message: 'User ID not found in authentication token'
      });
    }
    
    const { status, limit = 50, includeCompleted = false } = req.query;
    
    const query = { userId };
    
    if (status) {
      query.status = status;
    } else if (!includeCompleted || includeCompleted === 'false') {
      query.status = { $in: ['pending', 'snoozed'] };
    }
    
    const reminders = await FollowUpReminder.find(query)
      .populate('jobId', 'title company status location')
      .populate('followUpId', 'subject sentAt responseReceived')
      .sort({ scheduledDate: 1 })
      .limit(parseInt(limit));
    
    res.json({
      success: true,
      data: reminders,
      count: reminders.length
    });
  } catch (error) {
    console.error('Error fetching reminders:', error);
    res.status(500).json({
      success: false,
      message: 'Failed to fetch reminders',
      error: error.message
    });
  }
};

/**
 * Get reminders for a specific job
 */
export const getJobReminders = async (req, res) => {
  try {
    const userId = req.auth?.userId || req.auth?.payload?.sub;
    const { jobId } = req.params;
    
    if (!userId) {
      return res.status(401).json({
        success: false,
        message: 'User ID not found in authentication token'
      });
    }
    
    // Validate job belongs to user
    const job = await Job.findOne({ _id: jobId, userId });
    if (!job) {
      return res.status(404).json({
        success: false,
        message: 'Job not found'
      });
    }
    
    const reminders = await FollowUpReminder.find({ userId, jobId })
      .populate('followUpId', 'subject sentAt responseReceived')
      .sort({ scheduledDate: -1 });
    
    res.json({
      success: true,
      data: reminders
    });
  } catch (error) {
    console.error('Error fetching job reminders:', error);
    res.status(500).json({
      success: false,
      message: 'Failed to fetch job reminders',
      error: error.message
    });
  }
};

/**
 * Get pending reminders (due within specified days)
 */
export const getPendingReminders = async (req, res) => {
  try {
    const userId = req.auth?.userId || req.auth?.payload?.sub;
    const { days = 7 } = req.query;
    
    if (!userId) {
      return res.status(401).json({
        success: false,
        message: 'User ID not found in authentication token'
      });
    }
    
    const cutoffDate = new Date();
    cutoffDate.setDate(cutoffDate.getDate() + parseInt(days));
    
    const reminders = await FollowUpReminder.find({
      userId,
      status: { $in: ['pending', 'snoozed'] },
      scheduledDate: { $lte: cutoffDate }
    })
      .populate('jobId', 'title company status location')
      .sort({ scheduledDate: 1 });
    
    // Separate overdue from upcoming
    const now = new Date();
    const overdue = reminders.filter(r => r.scheduledDate < now);
    const upcoming = reminders.filter(r => r.scheduledDate >= now);
    
    res.json({
      success: true,
      data: {
        overdue,
        upcoming,
        total: reminders.length
      }
    });
  } catch (error) {
    console.error('Error fetching pending reminders:', error);
    res.status(500).json({
      success: false,
      message: 'Failed to fetch pending reminders',
      error: error.message
    });
  }
};

/**
 * Create a new follow-up reminder
 */
export const createReminder = async (req, res) => {
  try {
    const userId = req.auth?.userId || req.auth?.payload?.sub;
    const { jobId, type, title, description, scheduledDate, priority } = req.body;
    
    if (!userId) {
      return res.status(401).json({
        success: false,
        message: 'User ID not found in authentication token'
      });
    }
    
    if (!jobId) {
      return res.status(400).json({
        success: false,
        message: 'Job ID is required'
      });
    }
    
    const result = await createFollowUpReminder(userId, jobId, {
      type,
      title,
      description,
      baseDate: scheduledDate ? new Date(scheduledDate) : new Date(),
      priority,
      autoGenerated: false,
      force: true
    });
    
    if (result.skipped) {
      return res.status(400).json({
        success: false,
        message: result.reason
      });
    }
    
    res.status(201).json({
      success: true,
      message: result.existing ? 'Existing reminder found' : 'Reminder created successfully',
      data: result.reminder
    });
  } catch (error) {
    console.error('Error creating reminder:', error);
    res.status(500).json({
      success: false,
      message: 'Failed to create reminder',
      error: error.message
    });
  }
};

/**
 * Snooze a reminder
 */
export const snoozeReminder = async (req, res) => {
  try {
    const userId = req.auth?.userId || req.auth?.payload?.sub;
    const { reminderId } = req.params;
    const { days = 1, reason = '' } = req.body;
    
    if (!userId) {
      return res.status(401).json({
        success: false,
        message: 'User ID not found in authentication token'
      });
    }
    
    const reminder = await FollowUpReminder.findOne({ _id: reminderId, userId });
    
    if (!reminder) {
      return res.status(404).json({
        success: false,
        message: 'Reminder not found'
      });
    }
    
    if (reminder.status === 'completed' || reminder.status === 'dismissed') {
      return res.status(400).json({
        success: false,
        message: 'Cannot snooze a completed or dismissed reminder'
      });
    }
    
    reminder.snooze(parseInt(days), reason);
    await reminder.save();
    
    res.json({
      success: true,
      message: `Reminder snoozed for ${days} day(s)`,
      data: reminder
    });
  } catch (error) {
    console.error('Error snoozing reminder:', error);
    res.status(500).json({
      success: false,
      message: 'Failed to snooze reminder',
      error: error.message
    });
  }
};

/**
 * Dismiss a reminder
 */
export const dismissReminder = async (req, res) => {
  try {
    const userId = req.auth?.userId || req.auth?.payload?.sub;
    const { reminderId } = req.params;
    const { reason = '' } = req.body;
    
    if (!userId) {
      return res.status(401).json({
        success: false,
        message: 'User ID not found in authentication token'
      });
    }
    
    const reminder = await FollowUpReminder.findOne({ _id: reminderId, userId });
    
    if (!reminder) {
      return res.status(404).json({
        success: false,
        message: 'Reminder not found'
      });
    }
    
    reminder.dismiss(reason);
    await reminder.save();
    
    res.json({
      success: true,
      message: 'Reminder dismissed',
      data: reminder
    });
  } catch (error) {
    console.error('Error dismissing reminder:', error);
    res.status(500).json({
      success: false,
      message: 'Failed to dismiss reminder',
      error: error.message
    });
  }
};

/**
 * Complete a reminder
 */
export const completeReminder = async (req, res) => {
  try {
    const userId = req.auth?.userId || req.auth?.payload?.sub;
    const { reminderId } = req.params;
    const { method = 'marked-complete', notes = '', followUpId = null } = req.body;
    
    if (!userId) {
      return res.status(401).json({
        success: false,
        message: 'User ID not found in authentication token'
      });
    }
    
    const reminder = await FollowUpReminder.findOne({ _id: reminderId, userId });
    
    if (!reminder) {
      return res.status(404).json({
        success: false,
        message: 'Reminder not found'
      });
    }
    
    reminder.complete(method, notes, followUpId);
    await reminder.save();
    
    res.json({
      success: true,
      message: 'Reminder completed',
      data: reminder
    });
  } catch (error) {
    console.error('Error completing reminder:', error);
    res.status(500).json({
      success: false,
      message: 'Failed to complete reminder',
      error: error.message
    });
  }
};

/**
 * Get reminder statistics
 */
export const getReminderStats = async (req, res) => {
  try {
    const userId = req.auth?.userId || req.auth?.payload?.sub;
    
    if (!userId) {
      return res.status(401).json({
        success: false,
        message: 'User ID not found in authentication token'
      });
    }
    
    const now = new Date();
    
    // Get counts by status
    const statusCounts = await FollowUpReminder.aggregate([
      { $match: { userId } },
      { $group: { _id: '$status', count: { $sum: 1 } } }
    ]);
    
    // Get overdue count
    const overdueCount = await FollowUpReminder.countDocuments({
      userId,
      status: 'pending',
      scheduledDate: { $lt: now }
    });
    
    // Get upcoming count (next 7 days)
    const weekFromNow = new Date();
    weekFromNow.setDate(weekFromNow.getDate() + 7);
    const upcomingCount = await FollowUpReminder.countDocuments({
      userId,
      status: { $in: ['pending', 'snoozed'] },
      scheduledDate: { $gte: now, $lte: weekFromNow }
    });
    
    // Get completion rate
    const totalCompleted = await FollowUpReminder.countDocuments({
      userId,
      status: 'completed'
    });
    const totalReminders = await FollowUpReminder.countDocuments({ userId });
    const completionRate = totalReminders > 0 
      ? Math.round((totalCompleted / totalReminders) * 100) 
      : 0;
    
    // Get average response rate
    const respondedReminders = await FollowUpReminder.countDocuments({
      userId,
      status: 'completed',
      'companyResponsiveness.responseReceived': true
    });
    const responseRate = totalCompleted > 0
      ? Math.round((respondedReminders / totalCompleted) * 100)
      : 0;
    
    res.json({
      success: true,
      data: {
        statusCounts: statusCounts.reduce((acc, item) => {
          acc[item._id] = item.count;
          return acc;
        }, {}),
        overdueCount,
        upcomingCount,
        completionRate,
        responseRate,
        totalReminders
      }
    });
  } catch (error) {
    console.error('Error fetching reminder stats:', error);
    res.status(500).json({
      success: false,
      message: 'Failed to fetch reminder statistics',
      error: error.message
    });
  }
};

/**
 * Get etiquette tips for a reminder type
 */
export const getEtiquetteTipsEndpoint = async (req, res) => {
  try {
    const { type } = req.params;
    
    const tips = getEtiquetteTips(type);
    
    res.json({
      success: true,
      data: {
        type,
        tips
      }
    });
  } catch (error) {
    console.error('Error fetching etiquette tips:', error);
    res.status(500).json({
      success: false,
      message: 'Failed to fetch etiquette tips',
      error: error.message
    });
  }
};

/**
 * Get company responsiveness data
 */
export const getCompanyResponsivenessEndpoint = async (req, res) => {
  try {
    const userId = req.auth?.userId || req.auth?.payload?.sub;
    const { company } = req.params;
    
    if (!userId) {
      return res.status(401).json({
        success: false,
        message: 'User ID not found in authentication token'
      });
    }
    
    if (!company) {
      return res.status(400).json({
        success: false,
        message: 'Company name is required'
      });
    }
    
    const responsiveness = await getCompanyResponsiveness(userId, company);
    
    res.json({
      success: true,
      data: {
        company,
        ...responsiveness
      }
    });
  } catch (error) {
    console.error('Error fetching company responsiveness:', error);
    res.status(500).json({
      success: false,
      message: 'Failed to fetch company responsiveness',
      error: error.message
    });
  }
};

/**
 * Trigger reminder creation for a status change (manual trigger)
 */
export const triggerStatusChangeReminders = async (req, res) => {
  try {
    const userId = req.auth?.userId || req.auth?.payload?.sub;
    const { jobId } = req.params;
    const { newStatus, previousStatus } = req.body;
    
    if (!userId) {
      return res.status(401).json({
        success: false,
        message: 'User ID not found in authentication token'
      });
    }
    
    // Validate job belongs to user
    const job = await Job.findOne({ _id: jobId, userId });
    if (!job) {
      return res.status(404).json({
        success: false,
        message: 'Job not found'
      });
    }
    
    const result = await handleStatusChange(
      userId, 
      jobId, 
      newStatus || job.status, 
      previousStatus
    );
    
    res.json({
      success: true,
      message: result.skipped ? result.reason : 'Reminders updated for status change',
      data: result
    });
  } catch (error) {
    console.error('Error triggering status change reminders:', error);
    res.status(500).json({
      success: false,
      message: 'Failed to update reminders',
      error: error.message
    });
  }
};

/**
 * Mark response received for a completed reminder
 */
export const markResponseReceived = async (req, res) => {
  try {
    const userId = req.auth?.userId || req.auth?.payload?.sub;
    const { reminderId } = req.params;
    const { responseTime } = req.body;
    
    if (!userId) {
      return res.status(401).json({
        success: false,
        message: 'User ID not found in authentication token'
      });
    }
    
    const reminder = await FollowUpReminder.findOne({ _id: reminderId, userId });
    
    if (!reminder) {
      return res.status(404).json({
        success: false,
        message: 'Reminder not found'
      });
    }
    
    reminder.updateResponsiveness(true, responseTime);
    await reminder.save();
    
    res.json({
      success: true,
      message: 'Response marked as received',
      data: reminder
    });
  } catch (error) {
    console.error('Error marking response received:', error);
    res.status(500).json({
      success: false,
      message: 'Failed to mark response',
      error: error.message
    });
  }
};

/**
 * Delete a reminder
 */
export const deleteReminder = async (req, res) => {
  try {
    const userId = req.auth?.userId || req.auth?.payload?.sub;
    const { reminderId } = req.params;
    
    if (!userId) {
      return res.status(401).json({
        success: false,
        message: 'User ID not found in authentication token'
      });
    }
    
    const reminder = await FollowUpReminder.findOneAndDelete({ _id: reminderId, userId });
    
    if (!reminder) {
      return res.status(404).json({
        success: false,
        message: 'Reminder not found'
      });
    }
    
    res.json({
      success: true,
      message: 'Reminder deleted'
    });
  } catch (error) {
    console.error('Error deleting reminder:', error);
    res.status(500).json({
      success: false,
      message: 'Failed to delete reminder',
      error: error.message
    });
  }
};

/**
 * Bulk dismiss reminders for rejected applications
 */
export const dismissRejectedReminders = async (req, res) => {
  try {
    const userId = req.auth?.userId || req.auth?.payload?.sub;
    
    if (!userId) {
      return res.status(401).json({
        success: false,
        message: 'User ID not found in authentication token'
      });
    }
    
    // Find all jobs that are rejected, withdrawn, or ghosted
    const rejectedJobs = await Job.find({
      userId,
      status: { $in: ['Rejected', 'Withdrawn', 'Ghosted'] }
    }).select('_id');
    
    const jobIds = rejectedJobs.map(j => j._id);
    
    const result = await FollowUpReminder.updateMany(
      {
        userId,
        jobId: { $in: jobIds },
        status: { $in: ['pending', 'snoozed'] }
      },
      {
        $set: {
          status: 'dismissed',
          completedAt: new Date(),
          completionMethod: 'dismissed',
          completionNotes: 'Auto-dismissed due to rejected application'
        }
      }
    );
    
    res.json({
      success: true,
      message: `Dismissed ${result.modifiedCount} reminders for rejected applications`,
      data: {
        dismissedCount: result.modifiedCount
      }
    });
  } catch (error) {
    console.error('Error dismissing rejected reminders:', error);
    res.status(500).json({
      success: false,
      message: 'Failed to dismiss reminders',
      error: error.message
    });
  }
};

/**
 * Generate follow-up email template based on reminder type and job
 */
export const generateFollowUpEmailTemplate = async (req, res) => {
  try {
    const userId = req.auth?.userId || req.auth?.payload?.sub;
    const { reminderId } = req.params;
    
    if (!userId) {
      return res.status(401).json({
        success: false,
        message: 'User ID not found in authentication token'
      });
    }
    
    const reminder = await FollowUpReminder.findOne({ _id: reminderId, userId })
      .populate('jobId', 'title company status location');
    
    if (!reminder) {
      return res.status(404).json({
        success: false,
        message: 'Reminder not found'
      });
    }
    
    // Get user information
    const user = await User.findOne({ auth0Id: userId });
    if (!user) {
      return res.status(404).json({
        success: false,
        message: 'User not found'
      });
    }
    
    const job = reminder.jobId;
    const userName = user.name || 'Candidate';
    
    // Generate email template based on reminder type
    let subject = '';
    let body = '';
    
    switch (reminder.reminderType) {
      case 'application-follow-up':
        subject = `Following Up: ${job.title} Application`;
        body = `Dear Hiring Manager,

I hope this email finds you well. I wanted to follow up on my application for the ${job.title} position at ${job.company}, which I submitted on [APPLICATION_DATE].

I remain very interested in this opportunity and believe my skills and experience align well with the role's requirements. I would welcome the chance to discuss how I can contribute to ${job.company}'s continued success.

If there are any updates regarding my application status or if you need any additional information from me, please don't hesitate to reach out.

Thank you for your time and consideration.

Best regards,
${userName}`;
        break;
        
      case 'post-interview-thank-you':
        subject = `Thank You - ${job.title} Interview`;
        body = `Dear [INTERVIEWER_NAME],

Thank you for taking the time to meet with me ${reminder.applicationStage.includes('Phone') ? 'on the phone' : 'today'} to discuss the ${job.title} position at ${job.company}.

I greatly enjoyed our conversation about [SPECIFIC_TOPIC_DISCUSSED] and learning more about ${job.company}'s [SPECIFIC_PROJECT_OR_INITIATIVE]. The role aligns perfectly with my background in [YOUR_RELEVANT_EXPERIENCE], and I'm excited about the possibility of contributing to your team.

Our discussion reinforced my enthusiasm for this opportunity, particularly [MENTION_SPECIFIC_ASPECT_THAT_EXCITED_YOU].

Please let me know if you need any additional information from me. I look forward to hearing about the next steps in the process.

Thank you again for your time and consideration.

Best regards,
${userName}`;
        break;
        
      case 'post-interview-follow-up':
      case 'status-inquiry':
        subject = `Following Up: ${job.title} Interview`;
        body = `Dear [INTERVIEWER_NAME],

I wanted to follow up on our recent interview for the ${job.title} position at ${job.company}. I remain very enthusiastic about the opportunity to join your team.

Since our conversation, I've continued to think about [SPECIFIC_ASPECT_DISCUSSED] and how my experience with [YOUR_RELEVANT_SKILL] could contribute to ${job.company}'s goals.

I understand that hiring decisions take time, but I wanted to reiterate my strong interest in the role. If there are any updates you can share about the process timeline or if you need any additional information from me, I would be happy to provide it.

Thank you again for considering my application.

Best regards,
${userName}`;
        break;
        
      case 'feedback-request':
        subject = `Thank You and Feedback Request - ${job.title}`;
        body = `Dear Hiring Manager,

Thank you for considering me for the ${job.title} position at ${job.company}. While I'm disappointed to learn that I won't be moving forward in the process, I appreciate the time you invested in reviewing my application.

I'm committed to continuous improvement in my job search and professional development. If you have a moment, I would greatly appreciate any feedback you could share about my application or interview performance. Understanding areas where I could strengthen my candidacy would be extremely valuable.

I remain impressed by ${job.company}'s work and would welcome the opportunity to be considered for future roles that may be a better fit.

Thank you again for your time and consideration.

Best regards,
${userName}`;
        break;
        
      case 'offer-response':
        subject = `Re: ${job.title} Offer`;
        body = `Dear [HIRING_MANAGER_NAME],

Thank you for extending an offer for the ${job.title} position at ${job.company}. I'm excited about the opportunity and appreciate your confidence in my abilities.

I'm currently reviewing the offer details carefully. [IF_NEED_TIME: I would like to request until [DATE] to make my final decision, as I want to ensure this is the right fit for both of us.] [IF_QUESTIONS: I have a few questions about [BENEFITS/RESPONSIBILITIES/START_DATE] that I'd like to discuss.]

I remain very interested in joining ${job.company} and contributing to [SPECIFIC_TEAM_OR_PROJECT].

Could we schedule a time to discuss this further?

Thank you for your understanding.

Best regards,
${userName}`;
        break;
        
      case 'networking-follow-up':
        subject = `Staying in Touch - ${job.company}`;
        body = `Dear [CONTACT_NAME],

I wanted to reach out and thank you again for considering me for the ${job.title} position at ${job.company}. While the timing didn't work out this time, I remain very impressed by the work ${job.company} is doing in [INDUSTRY/FIELD].

I'm continuing to develop my skills in [RELEVANT_AREAS] and would love to stay connected for potential future opportunities. I'd also be happy to share any relevant insights or connections that might be valuable to your team.

Thank you again for your time and consideration. I hope we can keep in touch.

Best regards,
${userName}`;
        break;
        
      default:
        subject = `Following Up: ${job.title} at ${job.company}`;
        body = `Dear Hiring Manager,

I wanted to follow up regarding the ${job.title} position at ${job.company}.

I remain very interested in this opportunity and would welcome any updates you can share.

Thank you for your time and consideration.

Best regards,
${userName}`;
    }
    
    res.json({
      success: true,
      data: {
        reminderId: reminder._id,
        reminderType: reminder.reminderType,
        job: {
          title: job.title,
          company: job.company
        },
        template: {
          subject,
          body
        },
        etiquetteTips: reminder.etiquetteTips,
        suggestedActions: [
          'Personalize [BRACKETED_PLACEHOLDERS] with specific details',
          'Review and adjust tone based on your previous interactions',
          'Keep email concise and professional',
          'Proofread carefully before sending'
        ]
      }
    });
  } catch (error) {
    console.error('Error generating email template:', error);
    res.status(500).json({
      success: false,
      message: 'Failed to generate email template',
      error: error.message
    });
  }
};

export default {
  getAllReminders,
  getJobReminders,
  getPendingReminders,
  createReminder,
  snoozeReminder,
  dismissReminder,
  completeReminder,
  getReminderStats,
  getEtiquetteTipsEndpoint,
  getCompanyResponsivenessEndpoint,
  triggerStatusChangeReminders,
  markResponseReceived,
  deleteReminder,
  dismissRejectedReminders,
  generateFollowUpEmailTemplate
};
