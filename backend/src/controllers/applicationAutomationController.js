import { ApplicationPackage } from '../models/ApplicationPackage.js';
import { ApplicationAutomation, ApplicationTemplate, ApplicationChecklist } from '../models/ApplicationAutomation.js';
import { Job } from '../models/Job.js';
import { Resume } from '../models/Resume.js';
import { CoverLetter } from '../models/CoverLetter.js';
import { User } from '../models/User.js';
import { successResponse, errorResponse, sendResponse, ERROR_CODES, validationErrorResponse } from '../utils/responseFormat.js';
import { asyncHandler } from '../middleware/errorHandler.js';
import { analyzeApplicationPackageQuality } from '../utils/geminiService.js';

// ===============================================
// Application Package Management
// ===============================================

/**
 * Generate complete application package for a job
 * POST /api/applications/packages
 */
export const generateApplicationPackage = asyncHandler(async (req, res) => {
  const sub = req.auth?.payload?.sub || req.auth?.userId;
  const { jobId, resumeId, coverLetterId, portfolioUrl, autoTailor, additionalDocuments } = req.body;

  if (!jobId) {
    const { response, statusCode } = validationErrorResponse('Job ID is required', [{ field: 'jobId', message: 'Job ID is required' }]);
    return sendResponse(res, response, statusCode);
  }

  // Fetch job details
  const job = await Job.findOne({ _id: jobId, userId: sub });
  if (!job) {
    const { response, statusCode } = errorResponse('Job not found', 404, ERROR_CODES.NOT_FOUND);
    return sendResponse(res, response, statusCode);
  }

  // If no resume/cover letter provided, use most recent ones
  let selectedResumeId = resumeId;
  let selectedCoverLetterId = coverLetterId;

  if (!selectedResumeId) {
    const latestResume = await Resume.findOne({ userId: sub }).sort({ updatedAt: -1 });
    if (latestResume) selectedResumeId = latestResume._id;
  }

  if (!selectedCoverLetterId) {
    const latestCoverLetter = await CoverLetter.findOne({ userId: sub }).sort({ updatedAt: -1 });
    if (latestCoverLetter) selectedCoverLetterId = latestCoverLetter._id;
  }

  // Get user's portfolio from profile
  let portfolio = portfolioUrl;
  if (!portfolio) {
    const user = await User.findOne({ auth0Id: sub });
    portfolio = user?.website || '';
  }

  // Create application package
  const packageData = {
    userId: sub,
    jobId,
    resumeId: selectedResumeId,
    coverLetterId: selectedCoverLetterId,
    portfolioUrl: portfolio,
    additionalDocuments: additionalDocuments || [],
    status: 'ready',
    metadata: {
      companyName: job.company,
      jobTitle: job.title,
      applicationUrl: job.url || '',
      notes: autoTailor ? 'Auto-tailored for this position' : ''
    },
    autoGenerated: autoTailor || false,
    generationSettings: {
      tailoredForJob: autoTailor || false
    }
  };

  const applicationPackage = await ApplicationPackage.create(packageData);

  const { response, statusCode } = successResponse('Application package generated successfully', applicationPackage);
  return sendResponse(res, response, statusCode);
});

/**
 * Get all application packages
 * GET /api/applications/packages
 */
export const getApplicationPackages = asyncHandler(async (req, res) => {
  const sub = req.auth?.payload?.sub || req.auth?.userId;
  const { status, jobId } = req.query;

  const query = { userId: sub };
  if (status) query.status = status;
  if (jobId) query.jobId = jobId;

  const packages = await ApplicationPackage.find(query)
    .populate('jobId')
    .populate('resumeId')
    .populate('coverLetterId')
    .sort({ createdAt: -1 });

  const { response, statusCode } = successResponse('Application packages retrieved', packages);
  return sendResponse(res, response, statusCode);
});

/**
 * Update application package
 * PUT /api/applications/packages/:packageId
 */
export const updateApplicationPackage = asyncHandler(async (req, res) => {
  const sub = req.auth?.payload?.sub || req.auth?.userId;
  const { packageId } = req.params;
  const updateData = req.body;

  const applicationPackage = await ApplicationPackage.findOneAndUpdate(
    { _id: packageId, userId: sub },
    updateData,
    { new: true, runValidators: true }
  ).populate('jobId').populate('resumeId').populate('coverLetterId');

  if (!applicationPackage) {
    const { response, statusCode } = errorResponse('Application package not found', 404, ERROR_CODES.NOT_FOUND);
    return sendResponse(res, response, statusCode);
  }

  const { response, statusCode } = successResponse('Application package updated', applicationPackage);
  return sendResponse(res, response, statusCode);
});

/**
 * Delete application package
 * DELETE /api/applications/packages/:packageId
 */
export const deleteApplicationPackage = asyncHandler(async (req, res) => {
  const sub = req.auth?.payload?.sub || req.auth?.userId;
  const { packageId } = req.params;

  const applicationPackage = await ApplicationPackage.findOneAndDelete({ _id: packageId, userId: sub });

  if (!applicationPackage) {
    const { response, statusCode } = errorResponse('Application package not found', 404, ERROR_CODES.NOT_FOUND);
    return sendResponse(res, response, statusCode);
  }

  const { response, statusCode } = successResponse('Application package deleted');
  return sendResponse(res, response, statusCode);
});

// ===============================================
// Application Scheduling
// ===============================================

/**
 * Schedule application submission
 * POST /api/applications/schedule
 */
export const scheduleApplication = asyncHandler(async (req, res) => {
  const sub = req.auth?.payload?.sub || req.auth?.userId;
  const { packageId, scheduledFor, autoSubmit } = req.body;

  if (!packageId || !scheduledFor) {
    const errors = [];
    if (!packageId) errors.push({ field: 'packageId', message: 'Package ID is required' });
    if (!scheduledFor) errors.push({ field: 'scheduledFor', message: 'Scheduled date is required' });
    const { response, statusCode } = validationErrorResponse('Missing required fields', errors);
    return sendResponse(res, response, statusCode);
  }

  const scheduledDate = new Date(scheduledFor);
  if (scheduledDate < new Date()) {
    const { response, statusCode } = validationErrorResponse('Scheduled date must be in the future', [{ field: 'scheduledFor', message: 'Cannot schedule in the past' }]);
    return sendResponse(res, response, statusCode);
  }

  const applicationPackage = await ApplicationPackage.findOneAndUpdate(
    { _id: packageId, userId: sub },
    {
      scheduledFor: scheduledDate,
      status: 'scheduled',
      'metadata.autoSubmit': autoSubmit || false
    },
    { new: true }
  ).populate('jobId');

  if (!applicationPackage) {
    const { response, statusCode } = errorResponse('Application package not found', 404, ERROR_CODES.NOT_FOUND);
    return sendResponse(res, response, statusCode);
  }

  // Update job status if needed
  if (applicationPackage.jobId) {
    await Job.findByIdAndUpdate(applicationPackage.jobId._id, {
      status: 'Applied',
      applicationDate: scheduledDate
    });
  }

  const { response, statusCode} = successResponse('Application scheduled successfully', applicationPackage);
  return sendResponse(res, response, statusCode);
});

/**
 * Get scheduled applications
 * GET /api/applications/scheduled
 */
export const getScheduledApplications = asyncHandler(async (req, res) => {
  const sub = req.auth?.payload?.sub || req.auth?.userId;
  const { upcoming } = req.query;

  const query = { userId: sub, status: 'scheduled' };
  if (upcoming === 'true') {
    query.scheduledFor = { $gte: new Date() };
  }

  const scheduled = await ApplicationPackage.find(query)
    .populate('jobId')
    .populate('resumeId')
    .sort({ scheduledFor: 1 });

  const { response, statusCode } = successResponse('Scheduled applications retrieved', scheduled);
  return sendResponse(res, response, statusCode);
});

// ===============================================
// Automation Rules
// ===============================================

/**
 * Create automation rule
 * POST /api/applications/automation/rules
 */
export const createAutomationRule = asyncHandler(async (req, res) => {
  const sub = req.auth?.payload?.sub || req.auth?.userId;
  const ruleData = { ...req.body, userId: sub };

  const rule = await ApplicationAutomation.create(ruleData);

  const { response, statusCode } = successResponse('Automation rule created', rule);
  return sendResponse(res, response, statusCode);
});

/**
 * Get all automation rules
 * GET /api/applications/automation/rules
 */
export const getAutomationRules = asyncHandler(async (req, res) => {
  const sub = req.auth?.payload?.sub || req.auth?.userId;
  const { active } = req.query;

  const query = { userId: sub };
  if (active !== undefined) query.active = active === 'true';

  const rules = await ApplicationAutomation.find(query).sort({ createdAt: -1 });

  const { response, statusCode } = successResponse('Automation rules retrieved', rules);
  return sendResponse(res, response, statusCode);
});

/**
 * Update automation rule
 * PUT /api/applications/automation/rules/:ruleId
 */
export const updateAutomationRule = asyncHandler(async (req, res) => {
  const sub = req.auth?.payload?.sub || req.auth?.userId;
  const { ruleId } = req.params;

  const rule = await ApplicationAutomation.findOneAndUpdate(
    { _id: ruleId, userId: sub },
    req.body,
    { new: true, runValidators: true }
  );

  if (!rule) {
    const { response, statusCode } = errorResponse('Automation rule not found', 404, ERROR_CODES.NOT_FOUND);
    return sendResponse(res, response, statusCode);
  }

  const { response, statusCode } = successResponse('Automation rule updated', rule);
  return sendResponse(res, response, statusCode);
});

/**
 * Delete automation rule
 * DELETE /api/applications/automation/rules/:ruleId
 */
export const deleteAutomationRule = asyncHandler(async (req, res) => {
  const sub = req.auth?.payload?.sub || req.auth?.userId;
  const { ruleId } = req.params;

  const rule = await ApplicationAutomation.findOneAndDelete({ _id: ruleId, userId: sub });

  if (!rule) {
    const { response, statusCode } = errorResponse('Automation rule not found', 404, ERROR_CODES.NOT_FOUND);
    return sendResponse(res, response, statusCode);
  }

  const { response, statusCode } = successResponse('Automation rule deleted');
  return sendResponse(res, response, statusCode);
});

// ===============================================
// Application Templates
// ===============================================

/**
 * Create application template
 * POST /api/applications/templates
 */
export const createApplicationTemplate = asyncHandler(async (req, res) => {
  const sub = req.auth?.payload?.sub || req.auth?.userId;
  const templateData = { ...req.body, userId: sub };

  const template = await ApplicationTemplate.create(templateData);

  const { response, statusCode } = successResponse('Application template created', template);
  return sendResponse(res, response, statusCode);
});

/**
 * Get all application templates
 * GET /api/applications/templates
 */
export const getApplicationTemplates = asyncHandler(async (req, res) => {
  const sub = req.auth?.payload?.sub || req.auth?.userId;
  const { category } = req.query;

  const query = { userId: sub };
  if (category) query.category = category;

  const templates = await ApplicationTemplate.find(query).sort({ usageCount: -1, createdAt: -1 });

  const { response, statusCode } = successResponse('Application templates retrieved', templates);
  return sendResponse(res, response, statusCode);
});

/**
 * Update application template
 * PUT /api/applications/templates/:templateId
 */
export const updateApplicationTemplate = asyncHandler(async (req, res) => {
  const sub = req.auth?.payload?.sub || req.auth?.userId;
  const { templateId } = req.params;

  const template = await ApplicationTemplate.findOneAndUpdate(
    { _id: templateId, userId: sub },
    req.body,
    { new: true, runValidators: true }
  );

  if (!template) {
    const { response, statusCode } = errorResponse('Application template not found', 404, ERROR_CODES.NOT_FOUND);
    return sendResponse(res, response, statusCode);
  }

  const { response, statusCode } = successResponse('Application template updated', template);
  return sendResponse(res, response, statusCode);
});

/**
 * Delete application template
 * DELETE /api/applications/templates/:templateId
 */
export const deleteApplicationTemplate = asyncHandler(async (req, res) => {
  const sub = req.auth?.payload?.sub || req.auth?.userId;
  const { templateId } = req.params;

  const template = await ApplicationTemplate.findOneAndDelete({ _id: templateId, userId: sub });

  if (!template) {
    const { response, statusCode } = errorResponse('Application template not found', 404, ERROR_CODES.NOT_FOUND);
    return sendResponse(res, response, statusCode);
  }

  const { response, statusCode } = successResponse('Application template deleted');
  return sendResponse(res, response, statusCode);
});

// ===============================================
// Bulk Operations
// ===============================================

/**
 * Bulk apply to multiple jobs
 * POST /api/applications/bulk-apply
 */
export const bulkApply = asyncHandler(async (req, res) => {
  const sub = req.auth?.payload?.sub || req.auth?.userId;
  const { jobIds, resumeId, coverLetterId, scheduleDaysOffset, autoTailor } = req.body;

  if (!jobIds || !Array.isArray(jobIds) || jobIds.length === 0) {
    const { response, statusCode } = validationErrorResponse('Job IDs array is required', [{ field: 'jobIds', message: 'Provide at least one job ID' }]);
    return sendResponse(res, response, statusCode);
  }

  const results = {
    successful: [],
    failed: []
  };

  for (const jobId of jobIds) {
    try {
      const job = await Job.findOne({ _id: jobId, userId: sub });
      if (!job) {
        results.failed.push({ jobId, reason: 'Job not found' });
        continue;
      }

      // Generate package
      const packageData = {
        userId: sub,
        jobId,
        resumeId,
        coverLetterId,
        status: scheduleDaysOffset ? 'scheduled' : 'ready',
        metadata: {
          companyName: job.company,
          jobTitle: job.title,
          applicationUrl: job.url || ''
        },
        autoGenerated: true,
        generationSettings: {
          tailoredForJob: autoTailor || false
        }
      };

      if (scheduleDaysOffset) {
        const scheduledDate = new Date();
        scheduledDate.setDate(scheduledDate.getDate() + scheduleDaysOffset);
        packageData.scheduledFor = scheduledDate;
      }

      const applicationPackage = await ApplicationPackage.create(packageData);
      results.successful.push({ jobId, packageId: applicationPackage._id, jobTitle: job.title });

    } catch (error) {
      results.failed.push({ jobId, reason: error.message });
    }
  }

  const { response, statusCode } = successResponse(`Bulk application completed. ${results.successful.length} successful, ${results.failed.length} failed.`, results);
  return sendResponse(res, response, statusCode);
});

// ===============================================
// Application Checklists
// ===============================================

/**
 * Create application checklist for a job
 * POST /api/applications/checklists
 */
export const createApplicationChecklist = asyncHandler(async (req, res) => {
  const sub = req.auth?.payload?.sub || req.auth?.userId;
  const { jobId, items, template } = req.body;

  if (!jobId) {
    const { response, statusCode } = validationErrorResponse('Job ID is required', [{ field: 'jobId', message: 'Job ID is required' }]);
    return sendResponse(res, response, statusCode);
  }

  // Check if checklist already exists
  let checklist = await ApplicationChecklist.findOne({ userId: sub, jobId });

  if (checklist) {
    // Update existing
    checklist.items = items || checklist.items;
    checklist.template = template || checklist.template;
    await checklist.save();
  } else {
    // Create new
    const defaultItems = items || [
      { task: 'Tailor resume for this position', priority: 'high' },
      { task: 'Write customized cover letter', priority: 'high' },
      { task: 'Research company culture and values', priority: 'medium' },
      { task: 'Prepare portfolio/work samples', priority: 'medium' },
      { task: 'Submit application', priority: 'high' },
      { task: 'Follow up after 1 week', priority: 'low' }
    ];

    checklist = await ApplicationChecklist.create({
      userId: sub,
      jobId,
      items: defaultItems,
      template: template || 'default'
    });
  }

  const { response, statusCode } = successResponse('Application checklist created', checklist);
  return sendResponse(res, response, statusCode);
});

/**
 * Get application checklist for a job
 * GET /api/applications/checklists/:jobId
 */
export const getApplicationChecklist = asyncHandler(async (req, res) => {
  const sub = req.auth?.payload?.sub || req.auth?.userId;
  const { jobId } = req.params;

  const checklist = await ApplicationChecklist.findOne({ userId: sub, jobId }).populate('jobId');

  if (!checklist) {
    const { response, statusCode } = errorResponse('Checklist not found', 404, ERROR_CODES.NOT_FOUND);
    return sendResponse(res, response, statusCode);
  }

  const { response, statusCode } = successResponse('Application checklist retrieved', checklist);
  return sendResponse(res, response, statusCode);
});

/**
 * Update checklist item
 * PUT /api/applications/checklists/:jobId/items/:itemId
 */
export const updateChecklistItem = asyncHandler(async (req, res) => {
  const sub = req.auth?.payload?.sub || req.auth?.userId;
  const { jobId, itemId } = req.params;
  const { completed, autoCompleted, notes } = req.body;

  const checklist = await ApplicationChecklist.findOne({ userId: sub, jobId });

  if (!checklist) {
    const { response, statusCode } = errorResponse('Checklist not found', 404, ERROR_CODES.NOT_FOUND);
    return sendResponse(res, response, statusCode);
  }

  const item = checklist.items.id(itemId);
  if (!item) {
    const { response, statusCode } = errorResponse('Checklist item not found', 404, ERROR_CODES.NOT_FOUND);
    return sendResponse(res, response, statusCode);
  }

  if (completed !== undefined) {
    item.completed = completed;
    item.completedAt = completed ? new Date() : null;
  }
  if (autoCompleted !== undefined) item.autoCompleted = autoCompleted;
  if (notes !== undefined) item.notes = notes;

  await checklist.save();

  const { response, statusCode } = successResponse('Checklist item updated', checklist);
  return sendResponse(res, response, statusCode);
});

/**
 * Get all checklists for user
 * GET /api/applications/checklists
 */
export const getAllChecklists = asyncHandler(async (req, res) => {
  const sub = req.auth?.payload?.sub || req.auth?.userId;

  const checklists = await ApplicationChecklist.find({ userId: sub })
    .populate('jobId')
    .sort({ createdAt: -1 });

  const { response, statusCode } = successResponse('Checklists retrieved', checklists);
  return sendResponse(res, response, statusCode);
});

/**
 * Score application package quality using AI
 * UC-122: Application Package Quality Scoring
 * POST /api/applications/packages/score
 */
export const scoreApplicationPackage = asyncHandler(async (req, res) => {
  const sub = req.auth?.payload?.sub || req.auth?.userId;
  const { jobId, resumeId, coverLetterId } = req.body;

  if (!jobId) {
    const { response, statusCode } = validationErrorResponse('Job ID is required', [{ field: 'jobId', message: 'Job ID is required' }]);
    return sendResponse(res, response, statusCode);
  }

  // Fetch job details
  const job = await Job.findOne({ _id: jobId, userId: sub });
  if (!job) {
    const { response, statusCode } = errorResponse('Job not found', 404, ERROR_CODES.NOT_FOUND);
    return sendResponse(res, response, statusCode);
  }

  // Fetch resume - use provided ID, linked ID, or most recent
  let resume = null;
  const targetResumeId = resumeId || job.linkedResumeId;
  if (targetResumeId) {
    resume = await Resume.findOne({ _id: targetResumeId, userId: sub });
  }
  if (!resume) {
    resume = await Resume.findOne({ userId: sub }).sort({ updatedAt: -1 });
  }

  // Fetch cover letter - use provided ID, linked ID, or most recent
  let coverLetter = null;
  const targetCoverLetterId = coverLetterId || job.linkedCoverLetterId;
  if (targetCoverLetterId) {
    coverLetter = await CoverLetter.findOne({ _id: targetCoverLetterId, userId: sub });
  }
  if (!coverLetter) {
    coverLetter = await CoverLetter.findOne({ userId: sub }).sort({ updatedAt: -1 });
  }

  // Get user profile for LinkedIn data if available
  const user = await User.findOne({ auth0Id: sub });
  const userProfile = user ? {
    headline: user.headline,
    linkedIn: user.linkedIn,
    website: user.website,
    skills: user.skills,
    experience: user.experience
  } : null;

  // Calculate historical scores for comparison
  // Get previous quality scores from application packages
  const previousPackages = await ApplicationPackage.find({ 
    userId: sub, 
    'qualityScore.overallScore': { $exists: true } 
  }).select('qualityScore.overallScore');
  
  let historicalScores = null;
  if (previousPackages.length > 0) {
    const scores = previousPackages.map(p => p.qualityScore.overallScore);
    const averageScore = Math.round(scores.reduce((a, b) => a + b, 0) / scores.length);
    const topScore = Math.max(...scores);
    historicalScores = { averageScore, topScore };
  }

  // Analyze application package quality using AI
  const qualityAnalysis = await analyzeApplicationPackageQuality(
    job,
    resume,
    coverLetter,
    userProfile,
    historicalScores
  );

  // Store the quality score in the job for tracking
  job.lastQualityScore = {
    score: qualityAnalysis.overallScore,
    analyzedAt: new Date(),
    resumeId: resume?._id,
    coverLetterId: coverLetter?._id
  };
  await job.save();

  // Also update application package if exists
  const existingPackage = await ApplicationPackage.findOne({ jobId, userId: sub });
  if (existingPackage) {
    existingPackage.qualityScore = qualityAnalysis;
    existingPackage.lastAnalyzedAt = new Date();
    await existingPackage.save();
  }

  const { response, statusCode } = successResponse('Application package quality analyzed', {
    jobId,
    resumeId: resume?._id,
    coverLetterId: coverLetter?._id,
    qualityAnalysis,
    historicalScores,
    meetsThreshold: qualityAnalysis.overallScore >= 70
  });
  return sendResponse(res, response, statusCode);
});

